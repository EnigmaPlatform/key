name: BTC Private Key Finder

on:
  workflow_dispatch:
    inputs:
      target_address:
        description: 'Target Bitcoin address (compressed)'
        required: true
        default: '1PWo3JeB9jrGwfHDNpdGK54CRas7fsVzXU'
      start_range:
        description: 'Start range (hex)'
        required: true
        default: '0000000000000000000000000000000000000000000000400000000000000000'
      end_range:
        description: 'End range (hex)'
        required: true
        default: '00000000000000000000000000000000000000000000007fffffffffffffffff'
      chunk_size:
        description: 'Keys checked per sequential chunk'
        required: false
        default: '10000000'

jobs:
  run-finder:
    runs-on: ubuntu-latest
    timeout-minutes: 1440  # 24 hours maximum runtime

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python 3.10
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y python3-dev libssl-dev

    - name: Install Python packages
      run: |
        python -m pip install --upgrade pip
        pip install ecdsa base58 tqdm

    - name: Create and run BTC Finder script
      run: |
        cat > btc_finder.py << 'EOF'
        import hashlib
        import random
        import base58
        import ecdsa
        import time
        import logging
        import json
        import os
        from multiprocessing import Pool, cpu_count, Manager, Lock
        from tqdm import tqdm

        class Colors:
            GREEN = '\033[92m'
            RED = '\033[91m'
            YELLOW = '\033[93m'
            END = '\033[0m'

        # Configuration
        CHECKPOINT_FILE = "checked_ranges.json"
        CHUNK_SIZE = ${{ github.event.inputs.chunk_size }}
        RANDOM_ATTEMPTS = 100

        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('btc_key_finder.log'),
                logging.StreamHandler()
            ]
        )
        logger = logging.getLogger(__name__)

        def load_checked_ranges():
            if os.path.exists(CHECKPOINT_FILE):
                try:
                    with open(CHECKPOINT_FILE, 'r') as f:
                        return json.load(f)
                except:
                    return []
            return []

        def save_checked_ranges(ranges):
            with open(CHECKPOINT_FILE, 'w') as f:
                json.dump(ranges, f, indent=2)

        def is_key_in_ranges(key_int, ranges):
            for r in ranges:
                if r['start'] <= key_int <= r['end']:
                    return True
            return False

        def find_available_chunk(start_int, end_int, checked_ranges, chunk_size):
            current_pos = start_int
            while current_pos < end_int:
                chunk_end = min(current_pos + chunk_size - 1, end_int)
                overlap = False
                for r in checked_ranges:
                    if not (chunk_end < r['start'] or current_pos > r['end']):
                        overlap = True
                        current_pos = r['end'] + 1
                        break
                if not overlap:
                    return current_pos, chunk_end
            return None, None

        def log_success(private_key_hex, btc_address):
            message = f"""
            {Colors.GREEN}
            ╔═══════════════════════════════════════════════════╗
            ║                KEY FOUND!                         ║
            ╠═══════════════════════════════════════════════════╣
            ║ Private Key (HEX): {private_key_hex[:32]}...{private_key_hex[-32:]} ║
            ║ Bitcoin Address:   {btc_address} ║
            ║ Time Found:        {time.strftime('%Y-%m-%d %H:%M:%S')} ║
            ╚═══════════════════════════════════════════════════╝
            {Colors.END}
            """
            print(message)
            with open("found_key.txt", "a") as f:
                f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}]\n")
                f.write(f"Private Key: {private_key_hex}\n")
                f.write(f"Address: {btc_address}\n")
                f.write("-"*50 + "\n\n")

        def generate_compressed_address(private_key_hex):
            try:
                if len(private_key_hex) != 64:
                    raise ValueError("Invalid key length")
                private_key_bytes = bytes.fromhex(private_key_hex)
                sk = ecdsa.SigningKey.from_string(private_key_bytes, curve=ecdsa.SECP256k1)
                vk = sk.get_verifying_key()
                x = vk.pubkey.point.x()
                y = vk.pubkey.point.y()
                public_key_compressed = bytes.fromhex("02" + "%064x" % x) if y % 2 == 0 else bytes.fromhex("03" + "%064x" % x)
                sha256 = hashlib.sha256(public_key_compressed).digest()
                ripemd160 = hashlib.new('ripemd160')
                ripemd160.update(sha256)
                pubkey_hash = ripemd160.digest()
                extended_hash = b'\x00' + pubkey_hash
                checksum = hashlib.sha256(hashlib.sha256(extended_hash).digest()).digest()[:4]
                address = base58.b58encode(extended_hash + checksum).decode('utf-8')
                return address
            except Exception as e:
                logger.error(f"{Colors.RED}Address generation error: {e}{Colors.END}")
                return None

        def check_key(private_key_hex, target_address):
            address = generate_compressed_address(private_key_hex)
            return address == target_address

        def check_random_keys(start_int, end_int, target_address, checked_ranges, num_attempts):
            keys_checked = 0
            found_key = None
            for _ in range(num_attempts):
                random_int = random.randint(start_int, end_int)
                while is_key_in_ranges(random_int, checked_ranges):
                    random_int = random.randint(start_int, end_int)
                private_key_hex = format(random_int, '064x')
                if check_key(private_key_hex, target_address):
                    found_key = private_key_hex
                    break
                keys_checked += 1
            return found_key, keys_checked

        def check_sequential_chunk(start_int, end_int, target_address, checked_ranges):
            current = start_int
            found_key = None
            keys_checked = 0
            while current <= end_int and not found_key:
                private_key_hex = format(current, '064x')
                if check_key(private_key_hex, target_address):
                    found_key = private_key_hex
                    break
                current += 1
                keys_checked += 1
            return found_key, keys_checked, start_int, current - 1

        def main():
            target_address = "${{ github.event.inputs.target_address }}"
            start_range = "${{ github.event.inputs.start_range }}"
            end_range = "${{ github.event.inputs.end_range }}"
            
            start_int = int(start_range, 16)
            end_int = int(end_range, 16)
            total_keys = end_int - start_int + 1
            checked_ranges = load_checked_ranges()
            
            logger.info(f"\n{Colors.YELLOW}=== BTC PRIVATE KEY FINDER ==={Colors.END}")
            logger.info(f"Target Address: {target_address}")
            logger.info(f"Search Range: {start_range} to {end_range}")
            logger.info(f"Total Keys: {total_keys:,}")
            logger.info(f"Chunk Size: {CHUNK_SIZE:,} keys")
            logger.info(f"CPU Cores: {cpu_count()}")
            logger.info(f"Loaded {len(checked_ranges)} checked ranges")

            start_time = time.time()
            keys_checked_total = 0
            found = False

            try:
                with tqdm(total=total_keys, desc="Progress") as pbar:
                    while not found and keys_checked_total < total_keys:
                        found_key, keys_checked = check_random_keys(
                            start_int, end_int, target_address, checked_ranges, RANDOM_ATTEMPTS
                        )
                        keys_checked_total += keys_checked
                        pbar.update(keys_checked)
                        if found_key:
                            log_success(found_key, target_address)
                            found = True
                            break
                        
                        chunk_start, chunk_end = find_available_chunk(
                            start_int, end_int, checked_ranges, CHUNK_SIZE
                        )
                        if chunk_start is None:
                            logger.info("All available chunks checked")
                            break
                        
                        logger.info(f"Checking chunk: {hex(chunk_start)} to {hex(chunk_end)}")
                        found_key, keys_checked, chunk_actual_start, chunk_actual_end = check_sequential_chunk(
                            chunk_start, chunk_end, target_address, checked_ranges
                        )
                        keys_checked_total += keys_checked
                        pbar.update(keys_checked)
                        
                        checked_ranges.append({
                            'start': chunk_actual_start,
                            'end': chunk_actual_end,
                            'checked_at': time.strftime('%Y-%m-%d %H:%M:%S')
                        })
                        save_checked_ranges(checked_ranges)
                        
                        if found_key:
                            log_success(found_key, target_address)
                            found = True
                            break

            except KeyboardInterrupt:
                logger.info(f"{Colors.YELLOW}Search stopped by user{Colors.END}")
            finally:
                elapsed_time = time.time() - start_time
                logger.info(f"\nTotal keys checked: {keys_checked_total:,}")
                logger.info(f"Time elapsed: {elapsed_time:.2f} seconds")
                if elapsed_time > 0:
                    logger.info(f"Speed: {keys_checked_total/elapsed_time:,.2f} keys/sec")
                if not found:
                    logger.info(f"{Colors.RED}No matching key found{Colors.END}")

        if __name__ == "__main__":
            main()
        EOF

        python btc_finder.py

    - name: Upload results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: btc-finder-results
        path: |
          btc_key_finder.log
          found_key.txt
          checked_ranges.json
