name: BTC Key Finder (Hybrid Mode)

on:
  workflow_dispatch:
    inputs:
      target_address:
        description: 'Target Bitcoin address'
        required: true
        default: '1PWo3JeB9jrGwfHDNpdGK54CRas7fsVzXU'

jobs:
  hybrid-finder:
    runs-on: ubuntu-latest
    timeout-minutes: 1440

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y python3-dev libssl-dev
        pip install ecdsa base58 tqdm

    - name: Create and run hybrid script
      run: |
        cat << 'EOF' > btc_hybrid_finder.py
        import hashlib
        import random
        import base58
        import ecdsa
        import time
        import logging
        import json
        import os
        from tqdm import tqdm

        # Конфигурация
        CHECKPOINT_FILE = "hybrid_ranges.json"
        CHUNK_SIZE = 10_000_000  # 10 млн ключей после случайной точки
        MAIN_START = 0x400000000000000000
        MAIN_END = 0x7fffffffffffffffff

        # Настройка логгирования
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[logging.FileHandler('hybrid_finder.log'), logging.StreamHandler()]
        )
        logger = logging.getLogger(__name__)

        def load_progress():
            if os.path.exists(CHECKPOINT_FILE):
                with open(CHECKPOINT_FILE, 'r') as f:
                    return json.load(f)
            return {"checked_ranges": [], "random_attempts": 0}

        def save_progress(progress):
            with open(CHECKPOINT_FILE, 'w') as f:
                json.dump(progress, f, indent=2)

        def generate_address(private_key_hex):
            try:
                private_key_bytes = bytes.fromhex(private_key_hex)
                sk = ecdsa.SigningKey.from_string(private_key_bytes, curve=ecdsa.SECP256k1)
                vk = sk.get_verifying_key()
                x, y = vk.pubkey.point.x(), vk.pubkey.point.y()
                prefix = '02' if y % 2 == 0 else '03'
                public_key = bytes.fromhex(prefix + "%064x" % x)
                sha256 = hashlib.sha256(public_key).digest()
                ripemd160 = hashlib.new('ripemd160', sha256).digest()
                extended = b'\x00' + ripemd160
                checksum = hashlib.sha256(hashlib.sha256(extended).digest()[:4]
                return base58.b58encode(extended + checksum).decode('utf-8')
            except Exception as e:
                logger.error(f"Ошибка генерации: {e}")
                return None

        def check_chunk(start, end, target):
            current = start
            while current <= end:
                priv_hex = format(current, '064x')
                if generate_address(priv_hex) == target:
                    return priv_hex
                current += 1
            return None

        def main():
            target = "${ { github.event.inputs.target_address } }"
            progress = load_progress()
            checked_ranges = progress["checked_ranges"]

            while True:
                # 1. Генерируем случайную точку
                random_key = random.randint(MAIN_START, MAIN_END)
                
                # 2. Проверяем саму случайную точку
                random_hex = format(random_key, '064x')
                if generate_address(random_hex) == target:
                    logger.info(f"НАЙДЕНО В СЛУЧАЙНОЙ ТОЧКЕ: {random_hex}")
                    return

                # 3. Проверяем последующие 10M ключей
                chunk_end = min(random_key + CHUNK_SIZE - 1, MAIN_END)
                found_key = check_chunk(random_key, chunk_end, target)

                if found_key:
                    logger.info(f"НАЙДЕНО В БЛОКЕ: {found_key}")
                    return

                # 4. Сохраняем диапазон
                checked_ranges.append({
                    "start": random_key,
                    "end": chunk_end,
                    "type": "hybrid_chunk",
                    "checked_at": time.strftime('%Y-%m-%d %H:%M:%S')
                })
                progress["random_attempts"] += 1
                save_progress(progress)

                logger.info(f"Проверен блок: {hex(random_key)}...{hex(chunk_end)}")

        if __name__ == "__main__":
            main()
        EOF

        python btc_hybrid_finder.py

    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: hybrid-finder-results
        path: |
          hybrid_finder.log
          CHECKPOINT_FILE
